# Правила для AI-ассистента проекта FEONT

## Контекст проекта

**FEONT** — приложение для работы с графом знаний: организационные структуры, технические структуры, планы работ.

**Тип проекта:** Исследовательский инструмент для моделирования и эволюции бизнес-процессов через граф знаний на основе RDF/SHACL технологий.

**Архитектура:** Knowledge Graph-based приложение с динамической схемой.

**Статус:** В разработке (planning)

**Документация:** 
- Основная документация: `docs/project/project-docs.json`
- Правила документации: `docs/project-documentation-rules.md`
- Планирование: `docs/development/project-development.json`
- Журнал: `docs/journal/project-journal.json`

## Приоритетное использование инструментов

### Desktop Commander MCP (приоритет)

**КРИТИЧЕСКИ ВАЖНО:** Desktop Commander MCP должен использоваться приоритетно для всех операций с файловой системой.

**Когда использовать Desktop Commander:**
- Чтение файлов (всегда приоритетно над терминалом)
- Запись/создание файлов
- Редактирование файлов
- Поиск файлов и кода
- Создание директорий
- Перемещение файлов
- Любые другие операции с файловой системой

**Терминал используется ТОЛЬКО если:**
- Desktop Commander MCP недоступен
- Нужно выполнить системную команду (git, npm, docker и т.д.)
- Нужно запустить процесс/приложение

**Правило:** Всегда сначала пытаться использовать Desktop Commander, терминал — только как запасной вариант.

## Правила работы с RDF/SHACL/SPARQL

### Стандартные префиксы RDF

При работе с RDF всегда используй стандартные префиксы:

```
@prefix feont: <http://example.org/feont/> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
```

### Форматы RDF

**Приоритет форматов:**
1. **Turtle (.ttl)** — предпочтительный формат для разработки и хранения
2. **JSON-LD (.jsonld)** — для интеграции с веб-приложениями
3. **RDF/XML** — использовать только при необходимости совместимости

**Правила форматирования Turtle:**
- Использовать отступы для читаемости
- Группировать триплеты по субъектам
- Использовать сокращённую форму для литералов где возможно

### Named Graphs

Использовать Named Graphs для организации данных:

- `urn:ontology` — схема/онтология (классы, свойства)
- `urn:data` — экземпляры данных
- `urn:shacl:shapes` — SHACL shapes для валидации
- `urn:ontology:history` — история изменений схемы
- `urn:validation:results` — результаты валидации

**В SPARQL запросах всегда указывать граф:**
```sparql
SELECT ?s ?p ?o 
FROM <urn:data>
WHERE { ?s ?p ?o }
```

### SHACL (Shape Constraint Language)

- Использовать SHACL для валидации данных
- Хранить shapes в отдельном Named Graph (`urn:shacl:shapes`)
- Документировать все shapes в `docs/project/extensions/shacl/shapes-catalog.json`
- При изменении онтологии обновлять соответствующие shapes

**Пример структуры SHACL shape:**
```turtle
ex:PersonShape
  a sh:NodeShape ;
  sh:targetClass feont:Person ;
  sh:property [
    sh:path feont:name ;
    sh:datatype xsd:string ;
    sh:minCount 1 ;
    sh:maxCount 1
  ] .
```

### SPARQL запросы

**Правила написания SPARQL:**
- Всегда указывать Named Graph (FROM/FROM NAMED)
- Использовать понятные имена переменных
- Документировать сложные запросы
- Сохранять аналитические запросы в `docs/project/extensions/sparql/queries-library.json`

**Формат документирования запроса:**
- ID запроса
- Название и описание
- SPARQL код
- Дата создания
- Используемые Named Graphs

## Правила работы с Apache Jena/Fuseki

### Apache Jena Fuseki

- Использовать Fuseki как SPARQL endpoint
- SPARQL endpoint по умолчанию: `http://localhost:3030/ds/sparql`
- Использовать SPARQL 1.1 Update для изменения данных
- Проверять доступность endpoint перед запросами

### Apache Jena TDB2

- Использовать TDB2 для хранения триплетов
- Локальное хранилище: `data/tdb2/` (в проекте)
- Не коммитить базу данных в git (добавить в .gitignore)

### SHACL валидация через Jena

- Использовать Apache Jena SHACL для валидации
- Валидировать данные перед записью в граф
- Логировать результаты валидации в `urn:validation:results`

### Docker развёртывание

- Использовать Docker для запуска Fuseki
- Конфигурация в `docker/fuseki/`
- Использовать docker-compose для управления

## Правила разработки Frontend (Vue 3 + Quasar)

### Vue.js 3

- Использовать Composition API (приоритетно)
- TypeScript опционален, но рекомендуется
- Следовать стилю Vue 3: `<script setup>`, reactive, ref, computed

### Quasar Framework

- Использовать Quasar компоненты для UI
- Следовать Material Design принципам
- Использовать Quasar CLI для сборки проекта

### Визуализация графов

**Cytoscape.js** — для визуализации данных графа знаний:
- Использовать для интерактивных графов
- Настраивать layouts в `docs/project/extensions/visualization/graph-layouts.json`
- Оптимизировать для больших графов

**WebVOWL** — для визуализации онтологии:
- Использовать для отображения структуры классов и свойств
- Интегрировать для редактирования онтологии

**YASGUI** — для SPARQL запросов:
- Встроить в интерфейс для выполнения запросов
- Сохранять часто используемые запросы

### RDF библиотеки

Использовать для работы с RDF в браузере:
- **rdflib.js** — основная библиотека для работы с RDF
- **n3** — быстрый парсер Turtle/N3
- **jsonld** — работа с JSON-LD

### Формы

Использовать **@formkit/vue** для динамической генерации форм на основе SHACL shapes.

## Правила кодирования

### Общие принципы

- **Читаемость > краткость** — код должен быть понятным
- **Комментарии** — документировать сложную логику
- **Имена переменных** — использовать понятные, описательные имена
- **Консистентность** — следовать стилю существующего кода

### Дата и время

- Формат дат: `YYYY-MM-DD` (ISO 8601)
- Формат дат с временем: `YYYY-MM-DDTHH:MM:SSZ`
- Пример: `2025-11-30`, `2025-11-30T19:40:00Z`

### Файлы и пути

- Использовать относительные пути от корня проекта
- Unix-стиль разделителей (`/`) в путях
- Абсолютные пути только если необходимо

## Работа с документацией

### Структура документации

- **project-docs.json** — основная документация проекта (архитектура, стек, онтология)
- **project-development.json** — планирование разработки (задачи, структура)
- **project-journal.json** — журнал разработки (сессии, изменения)

### Обновление документации

- Обновлять `lastUpdated` при изменениях
- Связывать изменения через ссылки (`projectDocsRefs`, `developmentTasks`, `journalRefs`)
- Документировать важные решения в журнале

### Создание новых артефактов

- Создавать задачи в `project-development.json`
- Фиксировать изменения в `project-journal.json`
- Следовать структуре из `docs/project-documentation-rules.md`

### Планы и резюме чатов

- Создавать план в `docs/development/notes/chats/chat-plan/` перед началом работы
- Создавать резюме в `docs/development/notes/chats/chat-resume/` после завершения
- Связывать с задачами в `project-development.json`

### Предварительные документы

- Сохранять в `docs/development/notes/docs-preliminary/`
- Формат имени: `YY-MMDD-название.md` (например: `25-1130-documentation-system-proposal.md`)
- Включать метаданные (дата, автор, статус)

## Проверка окружения разработки

### Apache Jena Fuseki

Перед работой проверять:
- Доступность Fuseki сервера (`http://localhost:3030`)
- Работоспособность SPARQL endpoint
- Подключение к TDB2

### Docker (если используется)

- Статус контейнера Fuseki
- Доступность портов

### Node.js окружение (Frontend)

- Версия Node.js (рекомендуется LTS)
- Установленные пакеты (`package.json`)

**Примечание:** Для исследовательского проекта проверка окружения не критична, можно упростить.

## Специфика исследовательского проекта

### Гибкость

- Архитектура может меняться в процессе исследования
- Важно документировать изменения в журнале
- Критерии завершения задач могут быть более свободными

### Эксперименты

- Фиксировать эксперименты в журнале разработки
- Записывать результаты и выводы
- Документировать изменения онтологии

### Динамическая схема

- Изменения схемы происходят в реальном времени (без миграций)
- Версионирование через Named Graphs
- Важно отслеживать изменения онтологии

## Связанные документы

- `docs/project/project-docs.json` — основная документация
- `docs/project/project-documentation-rules.md` — правила документации
- `docs/development/project-development.json` — планирование
- `docs/journal/project-journal.json` — журнал
- `docs/development/notes/chats/` — планы и резюме чатов
- `docs/development/notes/docs-preliminary/` — предварительные документы

